#%RAML 1.0 Library

types:
  # where will all this live ideally/ when there is a compute service?

  ComputeConfig:
    additionalProperties: false
    properties:
      name: string
      parameters:
        required: false
        type: object

  # how do we want to ensure the collectionVariable is a collection variable?
  # presumably the compute service will check and err
  # but do we want to talk about constraints?
  AlphaDivComputeConfig:
    type: ComputeConfig
    additionalProperties: false
    properties:
      name:
        type: string
        enum: ['AlphaDivComputation']
      parameters:
        properties:
          collectionVariable: VariableSpec

  AbundanceComputeConfig:
    type: ComputeConfig
    additionalProperties: false
    properties:
      name:
        type: string
        enum: ['RelativeAbundanceComputation']
      parameters:
        properties:
          collectionVariable: VariableSpec

  BetaDivComputeConfig:
    type: ComputeConfig
    additionalProperties: false
    properties:
      name:
        type: string
        enum: ['BetaDivComputation']
      parameters:
        properties:
          collectionVariable: VariableSpec
          method:
            type: string
            enum: ['unifrac', 'wunifrac', 'bray', 'jaccard', 'jensen-shannon']

  # compute responses. for later, but leaving the draft here
  # the compute will be baked right in to the viz plugin for now
  # still need to draft the *ComputeData objects
  AbundanceComputePostResponse:
    additionalProperties: false
    properties:
      median:
        type: AbundanceComputation
      max:
        type: AbundanceComputation
      q3:
        type: AbundanceComputation
      var:
        type: AbundanceComputation

  AbundanceComputation:
    type: Computation
    additionalProperties: false
    properties: 
      data: AbundanceComputationData[]
      isCutoff:
        type: boolean
    
  AbundanceComputationData:
    additionalProperties: false
    properties:
      record: string
      taxon: string
      abundance: number

  AlphaDivComputePostRespose:
    additionalProperties: false
    properties:
      shannon:
        type: AlphaDivComputation
      simpson:
        type: AlphaDivComputation
      evenness:
        type: AlphaDivComputation

  AlphaDivComputation:
    type: Computation
    additionalProperties: false
    properties: 
      data: AlphaDivComputationData[]
      
  AlphaDivComputationData:
    additionalProperties: false
    properties:
      record: string
      alphaDiversity: number

  Computation:
    properties:
      computedVariableDetails:
        type: ComputedVariableDetails[]
      parameterSet:
        type: string[]
      computeDetails:
        type: string
        required: false

  ComputedVariableDetails:
    properties:
      computedVariableIds:
        type: string[] # if more than one, than must be a collection var
      computedVariableEntity:
        type: string  # all have to be of the same entity, so should be just one string
      computedVariableDisplayLabels:
        type: string[]
        required: false
      isCollection:
        type: boolean  # Might return only 1 var but it would still need to be able to act like collection var (ex. abundance returns only 1 taxon)
      defaultRange:
        type: number[]
        maxItems: 2
        minItems: 2
        required: false
      vocabulary:
        type: string[]
        required: false
      isOrdinal: 
        type: boolean
        required: false
        
  BetaDivComputePostResponse:
    additionalProperties: false
    properties:
      dissimilarity:
        type: BetaDivComputation

  BetaDivComputation:
    type: Computation
    additionalProperties: false
    properties:
      data:
        type: BetaDivComputationData[]
      pcoaVariance:
        type: number[]

  BetaDivComputationData:
    additionalProperties: false
    properties:
      record: string
      axis: number  # or string?
      coordinate: number


  # some questions here
  # what if there is more than one computed var? need multiple ranges?
  # - AB can we assume that if one computation returns multiple numeric vars, that they'd make a collection var so all have the same range?
  # - AB no, beta div phase dolphin will break this, because it wants to return beta div dissimilarity matrix *and* the pcoa results.
  # - AB but, should one computation return vars so different they aren't in a collection? In the beta div case, should the dissimilarity measures and pcoa results be different computations in the same app?
  # - AB phase 1 alpa, beta, abundance, correlation, and diff abund will be okay.
  # - AB but what really *is* a computation? Ideally one computation = 1 computed variable.
  # what if the computed var is categorical, edge case for now but still
  # - AB will need to return ordered vocabulary, and is ordinal, and...
  # need better name for computeName, not to be confused w name prop above?
  # what is computeName anyway?
  # two conceptual levels here ComputedVariableMetadata and ComputeMetadata
  # maybe Metadata -> ComputeMetadata and has a ComputedVariableMetadata child?
  # AB some apps may generalize to clinepi (ranked abundance). Maybe 'record' is a better name than 'SampleID' for sake of generalizability?
  # AB plot responses return the config. Should app responses also return a nice config?
  # AB don't forget about entities!

  # Proposal
  # 1. Apps are a list of computations
  # 2. Computations input parameters and output a single var or collection var. Computations have a name, unique set of parameters, computed var(s), and details on how it went.
  # 3. Computed vars are one output. Computed vars have names, displayNames, entities.
  # 4. Computed vars are either categorical or numeric, so must also carry the appropriate annotations (ex. display range, vocabulary)

  # The above means we would have the beta div app return a dissimilarity matrix and pcoa results as two computations. 
