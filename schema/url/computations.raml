#%RAML 1.0 Library

types:
  # where will all this live ideally/ when there is a compute service?

  ComputeConfig:
    additionalProperties: false
    properties:
      name: string
      studyId: string

  # how do we want to ensure the collectionVariable is a collection variable?
  # presumably the compute service will check and err
  # but do we want to talk about constraints?
  AlphaDivComputeConfig:
    type: ComputeConfig
    additionalProperties: false
    properties:
      collectionVariable: VariableSpec

  AbundanceComputeConfig:
    type: ComputeConfig
    additionalProperties: false
    properties:
      collectionVariable: VariableSpec

  DistanceMethod:
    type: string
    enum: ['unifrac', 'wunifrac', 'bray', 'jaccard', 'jensen-shannon']

  BetaDivComputeConfig:
    type: ComputeConfig
    additionalProperties: false
    properties:
      collectionVariable: VariableSpec
      method: DistanceMethod

  # compute responses. for later, but leaving the draft here
  # the compute will be baked right in to the viz plugin for now
  # still need to draft the *ComputeData objects

  # Realized there may be so many options someday, we don't want to have to list all of them here. 
  # Having parameter set at the top level should make for easier finding of computations
  AbundanceComputePostResponse:
    additionalProperties: false
    properties:
      computations: 
        type: AbundanceComputation[]
      parameterSets: 
        type: ParameterSet[]

  ParameterSet:
    additionalProperties: false
    properties:
      parameters: 
        type: string[]

  AbundanceComputation:
    type: Computation
    additionalProperties: false
    properties:
      recordVariableDetails:
        type: VariableDetails  # poor name
      isCutoff:
        type: boolean
  
  VariableDetails:
    type: VariableSpec
    properties:
      values: string[]  # or number[]?
  

  AlphaDivComputePostRespose:
    additionalProperties: false
    properties:
      computations: 
        type: AlphaDivComputation[]
      parameterSets: 
        type: ParameterSet[]

  AlphaDivComputation:
    type: Computation
    additionalProperties: false
    properties: 
      recordVariableDetails:
        type: VariableDetails  # poor name
      
  Computation:
    additionalProperties: false
    properties:
      computedVariableDetails: ComputedVariableDetails[]
      computeDetails?: string
      # add compute type? For example, to distinguish dissimilarity from pcoa results?

  ComputedVariableDetails:
    additionalProperties: false
    properties:
      variableId:
        type: string[] 
      entityId:
        type: string  # all have to be of the same entity, so should be just one string
      values:
        type: number[][]  # or string[][]??
      displayLabel:
        type: string[]
        required: false
      isCollection:
        type: boolean  # abundance comptued vars are but pcoa axes aren't.
      defaultRange:
        type: number[]
        maxItems: 2
        minItems: 2
        required: false
      vocabulary:
        type: string[]
        required: false
      isOrdinal: 
        type: boolean
        required: false
        
  BetaDivComputePostResponse:
    additionalProperties: false
    properties:
      computations: 
        type: BetaDivComputation[]
      parameterSets: 
        type: ParameterSet[]

  BetaDivComputation:
    type: Computation
    additionalProperties: false
    properties: 
      recordVariableDetails:
        type: VariableDetails  # poor name
      pcoaVariance:
        type: number[]


  # some questions here
  # what if there is more than one computed var? need multiple ranges?
  # - AB can we assume that if one computation returns multiple numeric vars, that they'd make a collection var so all have the same range?
  # - AB no, beta div phase dolphin will break this, because it wants to return beta div dissimilarity matrix *and* the pcoa results.
  # - AB but, should one computation return vars so different they aren't in a collection? In the beta div case, should the dissimilarity measures and pcoa results be different computations in the same app?
  # - AB phase 1 alpa, beta, abundance, correlation, and diff abund will be okay.
  # - AB but what really *is* a computation? Ideally one computation = 1 computed variable.
  # what if the computed var is categorical, edge case for now but still
  # - AB will need to return ordered vocabulary, and is ordinal, and...
  # need better name for computeName, not to be confused w name prop above?
  # what is computeName anyway?
  # two conceptual levels here ComputedVariableMetadata and ComputeMetadata
  # maybe Metadata -> ComputeMetadata and has a ComputedVariableMetadata child?
  # AB some apps may generalize to clinepi (ranked abundance). Maybe 'record' is a better name than 'SampleID' for sake of generalizability?
  # AB plot responses return the config. Should app responses also return a nice config?
  # AB don't forget about entities!

  # Proposal
  # 1. Apps are a list of computations
  # 2. Computations input parameters and output a single var or collection var. Computations have a name, unique set of parameters, computed var(s), and details on how it went.
  # 3. Computed vars are one output. Computed vars have names, displayNames, entities.
  # 4. Computed vars are either categorical or numeric, so must also carry the appropriate annotations (ex. display range, vocabulary)

  # The above means we would have the beta div app return a dissimilarity matrix and pcoa results as two computations. 
