#%RAML 1.0 Library

types:
  # where will all this live ideally/ when there is a compute service?

  ComputeConfig:
    additionalProperties: false
    properties:
      name: string
      parameters:
        required: false
        type: object

  # how do we want to ensure the collectionVariable is a collection variable?
  # presumably the compute service will check and err
  # but do we want to talk about constraints?
  AlphaDivComputeConfig:
    type: ComputeConfig
    additionalProperties: false
    properties:
      name:
        type: string
        enum: ['AlphaDivComputation']
      parameters:
        properties:
          collectionVariable: VariableSpec

  AbundanceComputeConfig:
    type: ComputeConfig
    additionalProperties: false
    properties:
      name:
        type: string
        enum: ['RelativeAbundanceComputation']
      parameters:
        properties:
          collectionVariable: VariableSpec

  BetaDivComputeConfig:
    type: ComputeConfig
    additionalProperties: false
    properties:
      name:
        type: string
        enum: ['BetaDivComputation']
      parameters:
        properties:
          collectionVariable: VariableSpec
          method:
            type: string
            enum: ['unifrac', 'wunifrac', 'bray', 'jaccard', 'jensen-shannon']

  # compute responses. for later, but leaving the draft here
  # the compute will be baked right in to the viz plugin for now
  # still need to draft the *ComputeData objects
  AbundanceComputePostResponse:
    additionalProperties: false
    properties:
      data:
        type: AbundanceComputeData # some data table with samples as rows
      appMetadata: AbundanceMetadata[] # one per computation.
      stats: string # none?

  AbundanceComputeData:
    additionalProperties: false
    properties:
      todo: string

  AbundanceMetadata:
    additionalProperties: false
    type: Metadata
    properties:
      wasCutoff:
        type: boolean

  AlphaDivComputePostRespose:
    additionalProperties: false
    properties:
      data:
        type: AlphaDivComputeData # some data table with samples as rows
      appMetadata:
        type: Metadata[]
      stats: string # none?

  AlphaDivComputeData:
    additionalProperties: false
    properties:
      todo: string

  BetaDivComputePostResponse:
    additionalProperties: false
    properties:
      data:
        type: BetaDivComputeData  # some data table with samples as rows
      appMetadata:
        type: Metadata[]
      stats: BetaDivStats[]

  BetaDivComputeData:
    additionalProperties: false
    properties:
      todo: string

  BetaDivStats:
    additionalProperties: false
    properties:
      pcoaVariance:
        type: number[]    # Ex. [0.5, 0.2, ...]

  # some questions here
  # what if there is more than one computed var? need multiple ranges?
  # what if the computed var is categorical, edge case for now but still
  # need better name for computeName, not to be confused w name prop above?
  # what is computeName anyway?
  # two conceptual levels here ComputedVariableMetadata and ComputeMetadata
  # maybe Metadata -> ComputeMetadata and has a ComputedVariableMetadata child?
  Metadata:
    additionalProperties: false
    properties:
      computedVariableColumnNames:
        type: string[]    # Ex. ['shannonâ€™]
      computedVariableLabels:
        type: string[]    # Ex. ['Alpha Diversity: Shannon']
        required: false
      computedVariableRange:
        type: number[]    # Ex. [0, 1]
        required: false
      computeDetails:
        type: string      # Ex. 'No convergence after 100 iterations'
      computeName:
        type: string # Ex. 'median'
